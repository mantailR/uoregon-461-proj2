// lex.yy.cxx generated by reflex 1.3.2 from quack.lxx

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             yy::location
#define REFLEX_OPTION_YYSTYPE             yy::parser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  yy
#define REFLEX_OPTION_bison_cc_parser     parser
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_header_file         "lex.yy.h"
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           yy
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "lex.yy.cxx"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "quack.lxx"

/* Quack scanner
 *
 * 2019 Fall version for RE/flex
 *
 */

#include "quack.tab.hxx"  /* Generated by bison. */
#include "Messages.h"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace yy {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int comment = 1;
  static const int tripleq = 2;
  static const int str = 3;
  virtual void yylloc_update(yy::location& yylloc)
  {
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.line = static_cast<unsigned int>(yylloc.begin.line + matcher().lines() - 1);
    yylloc.end.column = static_cast<unsigned int>(yylloc.begin.column + matcher().columns() - 1);
  }
  virtual int yylex(yy::parser::semantic_type *lvalp, yy::location *llocp)
  {
    return yylex(*lvalp, *llocp);
  }
  virtual int yylex(yy::parser::semantic_type& yylval, yy::location& yylloc);
};

} // namespace yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 12 "quack.lxx"

/* Externally visible file name --
* for error messages.
* FIXME: Need to extract this from structures that reflex passes
* or else find another way to dig it out.
*/
std::string yyfilename = "What file is this, anyway?";

/* Some strings can't be matched in one gulp.  We need
 * a buffer in which to assemble them from parts.
 */
std::string string_buf = "";

void yyerror (const std::string &msg, yy::position* where) {
     std::cout << where << ": " << msg;
}

/* Some long messages that don't fit well in the code below */

std::string BAD_ESC_MSG =
  "Illegal escape code; only \\\\, \\0, \\t, \\n, \\r, \\n are permitted";
std::string BAD_NL_STR =
  "Unclosed string?  Encountered newline in quoted string.";



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int yy::Lexer::yylex(yy::parser::semantic_type& yylval, yy::location& yylloc)
{
  static const char *REGEX_INITIAL = "(?m)(==)|([<]=)|([>]=)|([(-/:->\\x7b\\x7d])|(class)|(def)|(extends)|(if)|(elif)|(else)|(while)|(return)|(typecase)|(and)|(or)|(not)|([A-Z_a-z][0-9A-Z_a-z]*)|([0-9]+)|(\")|([\"][\"][\"])|([\\x09\\x0a\\x20]*)|([/][\\x2a])|([/][/].*)|(.)";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_comment = "(?m)([^\\x2a]*)|([\\x2a][^/])|([\\x2a][/])";
  static const reflex::Pattern PATTERN_comment(REGEX_comment);
  static const char *REGEX_tripleq = "(?m)((?:(?:[^\"])|(?:[\"][^\"])|(?:[\"][\"][^\"])|\\n)*)|([\"][\"][\"])";
  static const reflex::Pattern PATTERN_tripleq(REGEX_tripleq);
  static const char *REGEX_str = "(?m)([^\\x09\\x0a\"\\x5c]+)|(\\\\n)|(\\\\t)|(\\\\.)|(\\n)|(\")";
  static const reflex::Pattern PATTERN_str(REGEX_str);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  switch (start())
  {
    case INITIAL:
#line 53 "quack.lxx"
/* We start with some tokens that are not value-bearing,
   * i.e., the parser needs to know only which token was matched.
   */

  /* Multi-character punctuation with names */
    break;
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        matcher().scan();
        yylloc_update(yylloc);
        switch (matcher().accept())
        {
          case 0:
            if (matcher().at_end())
            {
#line 158 "quack.lxx"
{ return EOF; }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 53: ==
#line 53 "quack.lxx"
{ return parser::token::EQUALS; }
            break;
          case 2: // rule at line 54: [<]=
#line 54 "quack.lxx"
{ return parser::token::ATMOST; }
            break;
          case 3: // rule at line 55: [>]=
#line 55 "quack.lxx"
{ return parser::token::ATLEAST; }

   /* Single character punctuation.  Because a character
    * in C or C++ can be treated as an integer, Bison lets
    * us return a character as a token.
    * JFlex/Cup do not let you do this in Java.
    */
            break;
          case 4: // rule at line 62: [(-/:->\x7b\x7d]
#line 62 "quack.lxx"
{ return text()[0]; }

  /* Keywords are essentially another kind of punctuation,
   * but since they also match the identifier pattern, we
   * need to be sure we give their patterns *before* the
   * identifier pattern.  Most scanner generators work this
   * way, but WARNING for Python PLY users:  PLY prioritizes
   * by length of the regular expression!
   */

            break;
          case 5: // rule at line 72: class
#line 72 "quack.lxx"
{ return parser::token::CLASS; }
            break;
          case 6: // rule at line 73: def
#line 73 "quack.lxx"
{ return parser::token::DEF; }
            break;
          case 7: // rule at line 74: extends
#line 74 "quack.lxx"
{ return parser::token::EXTENDS; }
            break;
          case 8: // rule at line 75: if
#line 75 "quack.lxx"
{ return parser::token::IF; }
            break;
          case 9: // rule at line 76: elif
#line 76 "quack.lxx"
{ return parser::token::ELIF; }
            break;
          case 10: // rule at line 77: else
#line 77 "quack.lxx"
{ return parser::token::ELSE; }
            break;
          case 11: // rule at line 78: while
#line 78 "quack.lxx"
{ return parser::token::WHILE; }
            break;
          case 12: // rule at line 79: return
#line 79 "quack.lxx"
{ return parser::token::RETURN; }
            break;
          case 13: // rule at line 80: typecase
#line 80 "quack.lxx"
{ return parser::token::TYPECASE; }
            break;
          case 14: // rule at line 81: and
#line 81 "quack.lxx"
{ return parser::token::AND; }
            break;
          case 15: // rule at line 82: or
#line 82 "quack.lxx"
{ return parser::token::OR; }
            break;
          case 16: // rule at line 83: not
#line 83 "quack.lxx"
{ return parser::token::NOT; }

   /* The following tokens are value-bearing:
    * We pass a value back to the parser by copying
    * it into the yylval parameter.  The parser
    * expects string values for identifiers and
    * string literals in yylval.str.  It expects integer
    * values for integer literals in yylval.num.
    */

            break;
          case 17: // rule at line 93: [A-Z_a-z][0-9A-Z_a-z]*
#line 93 "quack.lxx"
{ yylval.str = strdup(text()); return parser::token::IDENT; }
            break;
          case 18: // rule at line 94: [0-9]+
#line 94 "quack.lxx"
{ yylval.num = atoi(text()); return parser::token::INT_LIT; }

  /* Strings, single and triple-quoted */
            break;
          case 19: // rule at line 97: "
#line 97 "quack.lxx"
{ string_buf = ""; start(str); }
            break;
          case 20: // rule at line 119: ["]["]["]
#line 119 "quack.lxx"
{ start(tripleq);  string_buf = ""; }

   /* The following pattern is basically zero or more occurrences of
    *    - Anything that isn't a quote
    *    - Or one quote followed by something else
    *    - Or two quotes followed by something else
    */
            break;
          case 21: // rule at line 141: [\x09\x0a\x20]*
#line 141 "quack.lxx"
{ ; }

   /* Multi-line comments */
            break;
          case 22: // rule at line 144: [/][\x2a]
#line 144 "quack.lxx"
{ start(comment); }
            break;
          case 23: // rule at line 150: [/][/].*
#line 150 "quack.lxx"
{ ; }

            break;
          case 24: // rule at line 152: .
#line 152 "quack.lxx"
{ yyerror("*** Unexpected character in line",
        new yy::position(&yyfilename, lineno(),columno())); }




            break;
        }
        break;
      case comment:
        matcher().pattern(PATTERN_comment);
        matcher().scan();
        yylloc_update(yylloc);
        switch (matcher().accept())
        {
          case 0:
            if (matcher().at_end())
            {
#line 158 "quack.lxx"
{ return EOF; }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 145: [^\x2a]*
#line 145 "quack.lxx"
{ ; }
            break;
          case 2: // rule at line 146: [\x2a][^/]
#line 146 "quack.lxx"
{ ; }
            break;
          case 3: // rule at line 147: [\x2a][/]
#line 147 "quack.lxx"
{ start(INITIAL); }

   /* Line end comments */
            break;
        }
        break;
      case tripleq:
        matcher().pattern(PATTERN_tripleq);
        matcher().scan();
        yylloc_update(yylloc);
        switch (matcher().accept())
        {
          case 0:
            if (matcher().at_end())
            {
#line 158 "quack.lxx"
{ return EOF; }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 126: (?:(?:[^"])|(?:["][^"])|(?:["]["][^"])|\n)*
#line 126 "quack.lxx"
{
    string_buf += text();
    }

    /* When we get the ending triple-quote, we return the
     * assembled buffer.
     */
            break;
          case 2: // rule at line 133: ["]["]["]
#line 133 "quack.lxx"
{
    yylval.str = strdup(string_buf.c_str());
    start(INITIAL);
    return parser::token::STRING_LIT;
    }


  /* Ignore whitespace */
            break;
        }
        break;
      case str:
        matcher().pattern(PATTERN_str);
        matcher().scan();
        yylloc_update(yylloc);
        switch (matcher().accept())
        {
          case 0:
            if (matcher().at_end())
            {
#line 158 "quack.lxx"
{ return EOF; }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 98: [^\x09\x0a"\x5c]+
#line 98 "quack.lxx"
{ string_buf += text(); }
            break;
          case 2: // rule at line 99: \\n
#line 99 "quack.lxx"
{ string_buf += "\n"; }
            break;
          case 3: // rule at line 100: \\t
#line 100 "quack.lxx"
{ string_buf += "\t"; } /* etc */
            break;
          case 4: // rule at line 101: \\.
#line 101 "quack.lxx"
{ yyerror(BAD_ESC_MSG, new yy::position(&yyfilename, lineno(),columno())); }
            break;
          case 5: // rule at line 102: \n
#line 102 "quack.lxx"
{ yyerror(BAD_NL_STR,  new yy::position(&yyfilename, lineno(),columno()) );
           start(INITIAL);
           yylval.str = strdup(string_buf.c_str());
           return parser::token::STRING_LIT;
          }
            break;
          case 6: // rule at line 107: "
#line 107 "quack.lxx"
{ start(INITIAL);
           yylval.str = strdup(string_buf.c_str());
           return parser::token::STRING_LIT;
         }



  /* Triple-quoted strings.  Not all in one gulp.
   * When we see """, we enter an exclusive state in which
   * anything other than """ is added to a buffer.  Only
   * another """ breaks us out of that state.
   */
            break;
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 161 "quack.lxx"

/* No main program here */

